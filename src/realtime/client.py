#!/usr/bin/env python3
"""
OpenAI Realtime API WebSocket client with streaming support.
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import Any, Callable, Dict, Optional

import websockets
from websockets.exceptions import ConnectionClosed, ConnectionClosedError, ConnectionClosedOK
from tenacity import (
    retry,
    retry_if_exception_type,
    stop_after_attempt,
    wait_exponential,
)

from ..config.env import get_settings
from ..integrations.yclients_adapter import YClientsAdapter
from ..utils.logger import get_logger
from .events import (
    ConversationItem,
    ConversationItemCreateEvent,
    EventType,
    IncomingEvent,
    InputTextContent,
    ResponseCancelEvent,
    ResponseCreateEvent,
    ResponseFunctionCallArgumentsDoneEvent,
    Role,
    SessionConfig,
    SessionUpdateEvent,
    StreamController,
    StreamState,
)
from .tools import get_system_instructions, get_tools

logger = get_logger(__name__)
settings = get_settings()


class OpenAIRealtimeClient:
    """OpenAI Realtime API WebSocket client for a single user session."""
    
    def __init__(self, yclients_adapter: YClientsAdapter, user_id: int):
        self.yclients_adapter = yclients_adapter
        self.user_id = user_id  # –ö–∞–∂–¥—ã–π –∫–ª–∏–µ–Ω—Ç –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        self.websocket: Optional[websockets.WebSocketServerProtocol] = None
        self.is_connected = False
        self.active_streams: Dict[int, StreamController] = {}
        self.pending_function_calls: Dict[str, Dict[str, Any]] = {}
        self._connection_task: Optional[asyncio.Task] = None
        self._listen_task: Optional[asyncio.Task] = None
        self._monitor_task: Optional[asyncio.Task] = None
        self._reconnect_attempts = 0
        self._max_reconnect_attempts = 10
        self._should_reconnect = True
        self._last_pong_time = datetime.utcnow()
        self._created_at = datetime.utcnow()
        
        logger.info(f"üîó Created dedicated OpenAI client for user {user_id}")
        
    async def connect(self) -> None:
        """Connect to OpenAI Realtime API."""
        if self.is_connected and self.websocket and not self.websocket.closed:
            logger.debug("Already connected to Realtime API")
            return
            
        try:
            logger.info(f"Connecting to OpenAI Realtime API... (attempt {self._reconnect_attempts + 1})")
            
            # Cancel existing tasks
            await self._cleanup_tasks()
            
            self.websocket = await websockets.connect(
                settings.get_realtime_ws_url(),
                extra_headers=settings.get_realtime_headers(),
                ping_interval=settings.WS_PING_INTERVAL,
                ping_timeout=settings.WS_PING_TIMEOUT,
                close_timeout=settings.WS_CONNECT_TIMEOUT,
                max_size=2**20,  # 1MB max message size
                compression=None,  # Disable compression for better performance
            )
            
            self.is_connected = True
            self._reconnect_attempts = 0
            logger.info("Connected to OpenAI Realtime API")
            
            # Initialize session
            await self._initialize_session()
            
            # Start listening for events
            self._listen_task = asyncio.create_task(self._listen_events())
            
            # Start connection monitoring
            self._monitor_task = asyncio.create_task(self._monitor_connection())
            
        except Exception as e:
            logger.error(f"Failed to connect to Realtime API: {e}")
            self.is_connected = False
            self._reconnect_attempts += 1
            raise
    
    async def disconnect(self) -> None:
        """Disconnect from OpenAI Realtime API."""
        self._should_reconnect = False
        
        if self.websocket and not self.websocket.closed:
            logger.info("Disconnecting from OpenAI Realtime API...")
            try:
                await self.websocket.close()
            except Exception as e:
                logger.warning(f"Error closing WebSocket: {e}")
        
        await self._cleanup_tasks()
        
        self.is_connected = False
        self.active_streams.clear()
        self.pending_function_calls.clear()
        
    async def _cleanup_tasks(self) -> None:
        """Clean up background tasks."""
        tasks_to_cancel = [
            ("listen", self._listen_task),
            ("connection", self._connection_task),
            ("monitor", self._monitor_task),
        ]
        
        for task_name, task in tasks_to_cancel:
            if task and not task.done():
                task.cancel()
                try:
                    await task
                except asyncio.CancelledError:
                    pass
                except Exception as e:
                    logger.warning(f"Error cancelling {task_name} task: {e}")
    
    async def _monitor_connection(self) -> None:
        """Monitor WebSocket connection health."""
        logger.info("üîç Started connection monitoring")
        
        while self._should_reconnect and self.is_connected:
            try:
                # Check if websocket is still alive
                if not self.websocket or self.websocket.closed:
                    logger.warning(" WebSocket is closed, triggering reconnection")
                    self.is_connected = False
                    self._connection_task = asyncio.create_task(self._reconnect())
                    break
                
                # Check if we haven't received pong for too long
                time_since_pong = (datetime.utcnow() - self._last_pong_time).seconds
                if time_since_pong > settings.WS_PING_TIMEOUT * 2:
                    logger.warning(f" No pong received for {time_since_pong}s, connection may be dead")
                    self.is_connected = False
                    self._connection_task = asyncio.create_task(self._reconnect())
                    break
                
                # Send ping to check connection
                try:
                    pong_waiter = await self.websocket.ping()
                    await asyncio.wait_for(pong_waiter, timeout=settings.WS_PING_TIMEOUT)
                    self._last_pong_time = datetime.utcnow()
                    logger.debug("Ping/pong successful")
                except asyncio.TimeoutError:
                    logger.warning("Ping timeout, connection may be dead")
                    self.is_connected = False
                    self._connection_task = asyncio.create_task(self._reconnect())
                    break
                except Exception as e:
                    logger.warning(f"Ping failed: {e}")
                    self.is_connected = False
                    self._connection_task = asyncio.create_task(self._reconnect())
                    break
                
                # Wait before next check
                await asyncio.sleep(settings.WS_PING_INTERVAL)
                
            except asyncio.CancelledError:
                logger.info("Connection monitoring cancelled")
                break
            except Exception as e:
                logger.error(f" Error in connection monitoring: {e}")
                await asyncio.sleep(5)  # Wait before retrying
        
        logger.info("Connection monitoring stopped")
    
    async def _reconnect(self) -> None:
        """Reconnect to WebSocket with exponential backoff."""
        if not self._should_reconnect:
            logger.info("Reconnection disabled, not attempting to reconnect")
            return
            
        if self._reconnect_attempts >= self._max_reconnect_attempts:
            logger.error(f"Max reconnection attempts ({self._max_reconnect_attempts}) reached, giving up")
            self._should_reconnect = False
            return
        
        # Exponential backoff
        delay = min(2 ** self._reconnect_attempts, 30)  # Max 30 seconds
        logger.warning(f"‚è≥ Attempting to reconnect in {delay}s... (attempt {self._reconnect_attempts + 1}/{self._max_reconnect_attempts})")
        
        await asyncio.sleep(delay)
        
        try:
            await self.connect()
            logger.info("Successfully reconnected to Realtime API")
            
            # Restore any active streams if needed
            if self.active_streams:
                logger.info(f"Restoring {len(self.active_streams)} active streams")
                
        except Exception as e:
            logger.error(f" Reconnection attempt failed: {e}")
            if self._should_reconnect:
                # Schedule another reconnection attempt
                self._connection_task = asyncio.create_task(self._reconnect())
    
    async def _initialize_session(self) -> None:
        """Initialize session with configuration."""
        # –°–æ–∑–¥–∞–µ–º —Å–æ–±—ã—Ç–∏–µ session.update –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è OpenAI
        session_event = {
            "type": "session.update",
            "session": {
                "modalities": ["text"],
                "instructions": get_system_instructions(),
                "voice": "alloy",
                "input_audio_format": "pcm16",
                "output_audio_format": "pcm16",
                "input_audio_transcription": {
                    "model": "whisper-1"
                },
                "turn_detection": {
                    "type": "server_vad",
                    "threshold": 0.5,
                    "prefix_padding_ms": 300,
                    "silence_duration_ms": 200
                },
                "tools": [tool.model_dump(exclude_unset=True) for tool in get_tools()],
                "tool_choice": "auto",
                "temperature": settings.OPENAI_TEMPERATURE,
                "max_response_output_tokens": settings.MAX_RESPONSE_LENGTH
            }
        }
        
        await self._send_event(session_event)
        logger.info("Session initialized with tools and instructions")
        
        # Log detailed session configuration for debugging
        session_config = session_event.get("session", {})
        logger.info(f"üîß Session configuration details:")
        logger.info(f"  Temperature: {session_config.get('temperature')}")
        logger.info(f"  Max tokens: {session_config.get('max_response_output_tokens')}")
        logger.info(f"  Modalities: {session_config.get('modalities')}")
        logger.info(f"  Tools count: {len(session_config.get('tools', []))}")
        
        # Log full instructions (system prompt)
        instructions = session_config.get('instructions', '')
        logger.info(f"System instructions (length: {len(instructions)} chars):")
        logger.info(f"Instructions: {instructions}")
    
    async def _send_event(self, event: Any) -> None:
        """Send event to WebSocket."""
        if not self.websocket or self.websocket.closed:
            raise ConnectionError("WebSocket not connected")
        
        # –ï—Å–ª–∏ —ç—Ç–æ Pydantic –º–æ–¥–µ–ª—å, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ dict
        if hasattr(event, 'dict'):
            event_data = event.dict(exclude_unset=True, by_alias=True)
        else:
            event_data = event
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –µ—Å—Ç—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ type
        if 'type' not in event_data:
            if hasattr(event, 'type'):
                event_data['type'] = event.type
            else:
                logger.error(f"Event missing 'type' field: {event_data}")
                raise ValueError("Event must have 'type' field")
            
        json_data = json.dumps(event_data, ensure_ascii=False)
        await self.websocket.send(json_data)
        
        event_type = event_data.get('type', 'unknown')
        logger.debug(f"Sent event: {event_type}")
        
        # For session.update, log more details
        if event_type == "session.update":
            logger.debug(f"Full session.update data: {json_data}")
        else:
            logger.debug(f"Event data: {json_data[:300]}...")
    
    async def _listen_events(self) -> None:
        """Listen for incoming WebSocket events."""
        logger.info("üéß Started listening for WebSocket events")
        
        try:
            async for message in self.websocket:
                if not self.is_connected:
                    logger.debug("Ignoring message - client not connected")
                    break
                    
                try:
                    event_data = json.loads(message)
                    event_type = event_data.get("type", "unknown")

                    await self._handle_event(event_data)
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse event JSON: {e}")
                    logger.debug(f"Raw message: {message[:200]}...")
                except Exception as e:
                    logger.error(f"Error handling event: {e}")
                    
        except (ConnectionClosed, ConnectionClosedError, ConnectionClosedOK) as e:
            logger.warning(f"‚ö†Ô∏è WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ: {type(e).__name__}")
            self.is_connected = False
            
            # Always try to reconnect unless explicitly disabled
            if self._should_reconnect:
                logger.info("üîÑ –ü–ª–∞–Ω–∏—Ä—É—é –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...")
                self._connection_task = asyncio.create_task(self._reconnect())
            else:
                logger.info("–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ")
                # Mark all active streams as error
                for stream in self.active_streams.values():
                    if stream.state == StreamState.STREAMING:
                        stream.state = StreamState.ERROR
        
        except Exception as e:
            logger.error(f" Unexpected error in event listener: {e}")
            self.is_connected = False
            
            # Try to reconnect on unexpected errors too
            if self._should_reconnect:
                logger.info("üîÑ –ü–ª–∞–Ω–∏—Ä—É—é –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ –æ—à–∏–±–∫–∏...")
                self._connection_task = asyncio.create_task(self._reconnect())
            
        finally:
            logger.info("üõë Event listener stopped")
    
    async def _handle_event(self, event_data: Dict[str, Any]) -> None:
        """Handle incoming WebSocket event."""
        event_type = event_data.get("type")
        
        if event_type == EventType.RESPONSE_TEXT_DELTA:
            await self._handle_text_delta(event_data)
        
        elif event_type == EventType.RESPONSE_TEXT_DONE:
            await self._handle_text_done(event_data)
        
        elif event_type == EventType.RESPONSE_FUNCTION_CALL_ARGUMENTS_DELTA:
            await self._handle_function_call_delta(event_data)
        
        elif event_type == EventType.RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE:
            await self._handle_function_call_done(event_data)
        
        elif event_type == EventType.RESPONSE_DONE:
            await self._handle_response_done(event_data)
        
        elif event_type == "response.created":
            await self._handle_response_created(event_data)
        
        elif event_type == EventType.ERROR:
            await self._handle_error(event_data)
        
        else:
            logger.debug(f"Unhandled event type: {event_type}")
    
    async def _handle_text_delta(self, event_data: Dict[str, Any]) -> None:
        """Handle text delta event."""
        response_id = event_data.get("response_id")
        delta = event_data.get("delta", "")
        
        # Find stream by response_id
        stream = self._find_stream_by_response_id(response_id)
        if not stream:
            logger.warning(f"‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º –¥–ª—è response.text.delta (response_id: {response_id})")
            return
        
        stream.accumulated_text += delta
        stream.state = StreamState.STREAMING
        
        # Call delta callback if set
        if hasattr(stream, '_delta_callback') and stream._delta_callback:
            try:
                await stream._delta_callback(delta, stream.accumulated_text)
            except Exception as e:
                logger.error(f"Error in delta callback: {e}")
    
    async def _handle_text_done(self, event_data: Dict[str, Any]) -> None:
        """Handle text done event."""
        response_id = event_data.get("response_id")
        final_text = event_data.get("text", "")
        
        stream = self._find_stream_by_response_id(response_id)
        if not stream:
            return
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω –ª–∏ —É–∂–µ —Å—Ç—Ä–∏–º
        if stream.state == StreamState.DONE:
            logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ —É–∂–µ —Ñ–∏–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {stream.user_id}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
            return
        
        stream.accumulated_text = final_text
        stream.state = StreamState.DONE
        
        # Call done callback if set
        if hasattr(stream, '_done_callback') and stream._done_callback:
            try:
                logger.info(f"–§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {stream.user_id}")
                await stream._done_callback(final_text)
            except Exception as e:
                logger.error(f"Error in done callback: {e}")
    
    async def _handle_function_call_delta(self, event_data: Dict[str, Any]) -> None:
        """Handle function call arguments delta."""
        call_id = event_data.get("call_id")
        delta = event_data.get("delta", "")
        
        if call_id not in self.pending_function_calls:
            self.pending_function_calls[call_id] = {
                "name": "",
                "arguments": "",
                "response_id": event_data.get("response_id")
            }
        
        self.pending_function_calls[call_id]["arguments"] += delta
        logger.debug(f"Function call {call_id} arguments delta: {delta}")
    
    async def _handle_function_call_done(self, event_data: Dict[str, Any]) -> None:
        """Handle function call arguments done."""
        call_id = event_data.get("call_id")
        function_name = event_data.get("name")
        arguments_str = event_data.get("arguments", "{}")
        
        logger.info(f"Function call done: {function_name} with call_id: {call_id}")
        
        try:
            # Parse arguments
            arguments = json.loads(arguments_str)
            
            # Execute function call
            result = await self._execute_function_call(function_name, arguments)
            
            # Send result back
            await self._send_function_result(call_id, result)
            
        except Exception as e:
            logger.error(f"Error executing function call {function_name}: {e}")
            await self._send_function_result(call_id, {
                "error": f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏: {str(e)}"
            })
        
        # Clean up
        self.pending_function_calls.pop(call_id, None)
    
    async def _execute_function_call(self, function_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Execute YCLIENTS function call."""
        logger.info(f"Executing function: {function_name} with args: {arguments}")
        
        # Map function names to adapter methods
        function_mapping = {
            "yclients_list_services": self.yclients_adapter.list_services,
            "yclients_search_slots": self.yclients_adapter.search_slots,
            "yclients_create_appointment": self.yclients_adapter.create_appointment,
            "yclients_list_doctors": self.yclients_adapter.list_doctors,
            "get_user_info": self.yclients_adapter.get_user_info,
            "register_user": self.yclients_adapter.register_user,
            "book_appointment_with_profile": self.yclients_adapter.book_appointment_with_profile,
            "sync_user_profile": self.yclients_adapter.sync_user_profile
        }
        
        if function_name not in function_mapping:
            raise ValueError(f"Unknown function: {function_name}")
        
        func = function_mapping[function_name]
        
        # –î–ª—è —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º telegram_id –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        user_context_functions = {
            "get_user_info", "register_user", "book_appointment_with_profile", 
            "sync_user_profile"
        }
        
        if function_name in user_context_functions:
            # –ï—Å–ª–∏ telegram_id –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º user_id –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∫–ª–∏–µ–Ω—Ç–∞
            if "telegram_id" not in arguments or arguments.get("telegram_id") is None:
                arguments["telegram_id"] = self.user_id
        
        try:
            result = await func(**arguments)
            return {"success": True, "data": result}
        
        except Exception as e:
            logger.error(f"Function {function_name} failed: {e}")
            return {"success": False, "error": str(e)}
    
    async def _send_function_result(self, call_id: str, result: Dict[str, Any]) -> None:
        """Send function call result back to the API."""
        # Create function call output item –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
        event = {
            "type": "conversation.item.create",
            "item": {
                "type": "function_call_output",
                "call_id": call_id,
                "output": json.dumps(result, ensure_ascii=False)
            }
        }
        
        await self._send_event(event)
        logger.info(f"üì§ Sent function result for call_id: {call_id}")
        
        # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        await asyncio.sleep(0.2)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        active_stream = None
        for user_id, stream in self.active_streams.items():
            if stream.state not in [StreamState.DONE, StreamState.ERROR, StreamState.CANCELLED]:
                active_stream = stream
                break
        
        if active_stream:
            # –í–ê–ñ–ù–û: –ü–æ—Å–ª–µ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
            # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
            response_event = {
                "type": "response.create",
                "response": {
                    "modalities": ["text"],
                    "temperature": 1.1,
                    "max_output_tokens": 1500
                }
            }
            await self._send_event(response_event)
            logger.info(f"üîÑ Requested text generation after function call {call_id}")
        else:
            logger.warning(f"‚ö†Ô∏è No active stream found after function call {call_id}, skipping response.create")
    
    async def _handle_response_done(self, event_data: Dict[str, Any]) -> None:
        """Handle response done event."""
        response_id = event_data.get("response", {}).get("id")
        
        stream = self._find_stream_by_response_id(response_id)
        if stream and stream.state == StreamState.STREAMING:
            stream.state = StreamState.DONE
    
    async def _handle_response_created(self, event_data: Dict[str, Any]) -> None:
        """Handle response created event."""
        response = event_data.get("response", {})
        temperature = response.get("temperature")
        response_id = response.get("id")
        
        logger.info(f"üîç –î–µ—Ç–∞–ª–∏ —Å–æ–±—ã—Ç–∏—è response.created: {event_data}")
        logger.info(f"üå°Ô∏è Response created with temperature: {temperature}, response_id: {response_id}")
        
        # Find and update stream with response_id
        stream_updated = False
        for user_id, stream in self.active_streams.items():
            # –°–≤—è–∑—ã–≤–∞–µ–º —Å –ª—é–±—ã–º –∞–∫—Ç–∏–≤–Ω—ã–º —Å—Ç—Ä–∏–º–æ–º, –∫–æ—Ç–æ—Ä—ã–π –µ—â–µ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω
            if stream.state not in [StreamState.DONE, StreamState.ERROR, StreamState.CANCELLED]:
                # –û–±–Ω–æ–≤–ª—è–µ–º response_id (–º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–æ–≤—ã–π –ø–æ—Å–ª–µ function call)
                old_response_id = getattr(stream, 'response_id', None)
                stream.response_id = response_id
                
                # –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–π–º—Å—Ç–∞–º–ø —Å–æ–∑–¥–∞–Ω–∏—è response –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–≤–∏—Å—à–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤
                stream.response_created_at = datetime.utcnow()
                stream_updated = True
                
                if old_response_id != response_id:
                    logger.info(f"üîÑ –û–±–Ω–æ–≤–∏–ª–∏ response_id –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {old_response_id} ‚Üí {response_id}")
                else:
                    logger.info(f"üîó –°–≤—è–∑–∞–ª–∏ OpenAI response_id {response_id} —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {user_id}")
                break
        
        if not stream_updated:
            logger.warning(f"‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º –¥–ª—è response_id {response_id}")
            
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–∞–≤–∏—Å—à–µ–≥–æ response
        asyncio.create_task(self._monitor_response_timeout(response_id))
    
    async def _handle_error(self, event_data: Dict[str, Any]) -> None:
        """Handle error event."""
        error = event_data.get("error", {})
        error_message = error.get("message", "Unknown error")
        logger.error(f"Realtime API error: {error_message}")
        
        # Mark all active streams as error
        for stream in self.active_streams.values():
            if stream.state == StreamState.STREAMING:
                stream.state = StreamState.ERROR
                if hasattr(stream, '_error_callback') and stream._error_callback:
                    try:
                        await stream._error_callback(Exception(error_message))
                    except Exception as e:
                        logger.error(f"Error in error callback: {e}")
    
    def _find_stream_by_response_id(self, response_id: str) -> Optional[StreamController]:
        """Find active stream by response ID."""
        for stream in self.active_streams.values():
            if stream.response_id == response_id:
                return stream
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ, –∏—â–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç—Ä–∏–º –±–µ–∑ response_id
        # (—ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–æ–≤—ã–π —Å—Ç—Ä–∏–º, –∫–æ—Ç–æ—Ä—ã–π –µ—â–µ –Ω–µ –ø–æ–ª—É—á–∏–ª response_id)
        for stream in self.active_streams.values():
            if (stream.response_id is None and 
                stream.state in [StreamState.IDLE, StreamState.STREAMING]):
                # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º response_id –∫ —ç—Ç–æ–º—É —Å—Ç—Ä–∏–º—É
                stream.response_id = response_id
                logger.info(f"üîó –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–≤—è–∑–∞–ª–∏ response_id {response_id} —Å–æ —Å—Ç—Ä–∏–º–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {stream.user_id}")
                return stream
        
        return None
    
    async def _monitor_response_timeout(self, response_id: str) -> None:
        """Monitor response for timeout and cancel if hanging."""
        # –ñ–¥–µ–º 20 —Å–µ–∫—É–Ω–¥ - –µ—Å–ª–∏ –∑–∞ —ç—Ç–æ –≤—Ä–µ–º—è –Ω–µ—Ç –Ω–∏–∫–∞–∫–æ–≥–æ –æ—Ç–≤–µ—Ç–∞, –æ—Ç–º–µ–Ω—è–µ–º
        await asyncio.sleep(20)
        
        # –ò—â–µ–º —Å—Ç—Ä–∏–º –ø–æ response_id
        stream = self._find_stream_by_response_id(response_id)
        if not stream:
            return
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ–ª—É—á–∏–ª–∏ –ª–∏ –º—ã —É–∂–µ –∫–∞–∫–æ–π-—Ç–æ —Ç–µ–∫—Å—Ç
        if stream.accumulated_text.strip():
            logger.debug(f"Response {response_id} —É–∂–µ –ø–æ–ª—É—á–∏–ª —Ç–µ–∫—Å—Ç, –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–µ –Ω—É–∂–µ–Ω")
            return
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω –ª–∏ —É–∂–µ —Å—Ç—Ä–∏–º
        if stream.state in [StreamState.DONE, StreamState.ERROR, StreamState.CANCELLED]:
            return
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º—Å—Ç–∞–º–ø —Å–æ–∑–¥–∞–Ω–∏—è response
        if hasattr(stream, 'response_created_at'):
            time_elapsed = (datetime.utcnow() - stream.response_created_at).total_seconds()
            if time_elapsed > 20:
                logger.warning(f"‚è∞ Response {response_id} –∑–∞–≤–∏—Å –±–æ–ª–µ–µ 20 —Å–µ–∫—É–Ω–¥ –±–µ–∑ –æ—Ç–≤–µ—Ç–∞, –æ—Ç–º–µ–Ω—è–µ–º")
                
                try:
                    # –û—Ç–º–µ–Ω—è–µ–º –∑–∞–≤–∏—Å—à–∏–π response
                    cancel_event = {"type": "response.cancel"}
                    await self._send_event(cancel_event)
                    logger.info(f"‚ùå –û—Ç–º–µ–Ω–µ–Ω –∑–∞–≤–∏—Å—à–∏–π response {response_id}")
                    
                    # –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –∏ –ø—Ä–æ–±—É–µ–º —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π
                    await asyncio.sleep(1)
                    
                    # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π response —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å—Ç—Ä–∏–º –≤—Å–µ –µ—â–µ –∞–∫—Ç–∏–≤–µ–Ω
                    if stream.state not in [StreamState.DONE, StreamState.ERROR, StreamState.CANCELLED]:
                        response_event = {
                            "type": "response.create",
                            "response": {
                                "modalities": ["text"],
                                "temperature": 1.0,  # –ù–µ–º–Ω–æ–≥–æ —Å–Ω–∏–∂–∞–µ–º —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—É –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
                                "max_output_tokens": 1500
                            }
                        }
                        await self._send_event(response_event)
                        logger.info(f"üîÑ –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π response –≤–∑–∞–º–µ–Ω –∑–∞–≤–∏—Å—à–µ–≥–æ {response_id}")
                        
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –∑–∞–≤–∏—Å—à–µ–≥–æ response {response_id}: {e}")
    
    async def ensure_connected(self) -> None:
        """Ensure WebSocket is connected, reconnect if needed."""
        if not self.is_connected or not self.websocket or self.websocket.closed:
            logger.info("Connection lost, attempting to reconnect...")
            await self.connect()
    
    async def send_user_message(
        self,
        user_id: int,
        text: str,
        message_id: Optional[int] = None
    ) -> StreamController:
        """Send user message and return stream controller."""
        # Ensure we're connected
        await self.ensure_connected()
        
        # Cancel any existing stream for this user
        if user_id in self.active_streams:
            await self.cancel_stream(user_id)
        
        # Create stream controller
        stream = StreamController(
            user_id=user_id,
            message_id=message_id,
            state=StreamState.IDLE
        )
        self.active_streams[user_id] = stream
        
        try:
            # Create conversation item –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
            create_event = {
                "type": "conversation.item.create",
                "item": {
                    "type": "message",
                    "role": "user",
                    "content": [
                        {
                            "type": "input_text",
                            "text": text
                        }
                    ]
                }
            }
            await self._send_event(create_event)
            
            # Create response
            response_event = {
                "type": "response.create"
            }
            await self._send_event(response_event)
            
            logger.info(f"Sent user message from user {user_id}: {text[:50]}...")
            
        except Exception as e:
            logger.error(f"Failed to send user message: {e}")
            stream.state = StreamState.ERROR
            raise
        
        return stream
    
    async def cancel_stream(self, user_id: int) -> None:
        """Cancel active stream for user."""
        stream = self.active_streams.get(user_id)
        if not stream:
            logger.debug(f"No active stream found for user {user_id}")
            return
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å—Ç—Ä–∏–º–∞
        if stream.state in [StreamState.DONE, StreamState.ERROR, StreamState.CANCELLED]:
            logger.info(f"üóëÔ∏è –û—á–∏—â–µ–Ω —Å—Ç—Ä–∏–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            self.active_streams.pop(user_id, None)
            return
        
        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º cancel —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å—Ç—Ä–∏–º –∞–∫—Ç–∏–≤–µ–Ω
            if stream.state in [StreamState.STREAMING, StreamState.IDLE]:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω—ã–π response –¥–ª—è –æ—Ç–º–µ–Ω—ã
                if hasattr(stream, 'response_id') and stream.response_id:
                    logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω cancel –¥–ª—è response_id: {stream.response_id}")
                    cancel_event = {
                        "type": "response.cancel"
                    }
                    await self._send_event(cancel_event)
                    
                    # –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ, —á—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∞ –ø—Ä–æ—à–ª–∞
                    await asyncio.sleep(0.1)
                else:
                    logger.debug(f"–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ response –¥–ª—è –æ—Ç–º–µ–Ω—ã —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            
            stream.state = StreamState.CANCELLED
            
            # –û—á–∏—â–∞–µ–º response_id –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –ø–æ–ø—ã—Ç–æ–∫
            if hasattr(stream, 'response_id'):
                stream.response_id = None
                
            logger.info(f"üóëÔ∏è –û—á–∏—â–µ–Ω —Å—Ç—Ä–∏–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")
            
        except Exception as e:
            logger.error(f"Failed to cancel stream: {e}")
            # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –≤—Å–µ —Ä–∞–≤–Ω–æ –æ—á–∏—â–∞–µ–º —Å—Ç—Ä–∏–º
        
        finally:
            # Remove from active streams
            self.active_streams.pop(user_id, None)
    
    def set_stream_callbacks(
        self,
        user_id: int,
        on_delta: Optional[Callable[[str, str], Any]] = None,
        on_done: Optional[Callable[[str], Any]] = None,
        on_error: Optional[Callable[[Exception], Any]] = None,
    ) -> None:
        """Set callbacks for stream events."""
        stream = self.active_streams.get(user_id)
        if not stream:
            return
        
        if on_delta:
            stream._delta_callback = on_delta
        if on_done:
            stream._done_callback = on_done
        if on_error:
            stream._error_callback = on_error
    
    def get_stream_state(self, user_id: int) -> Optional[StreamState]:
        """Get current stream state for user."""
        stream = self.active_streams.get(user_id)
        return stream.state if stream else None
    
    def cleanup_finished_streams(self) -> None:
        """Clean up finished streams."""
        finished_users = []
        for user_id, stream in self.active_streams.items():
            if stream.state in [StreamState.DONE, StreamState.ERROR, StreamState.CANCELLED]:
                # Keep stream for a short while to allow final callbacks
                if (datetime.utcnow() - stream.created_at).seconds > 60:
                    finished_users.append(user_id)
        
        for user_id in finished_users:
            self.active_streams.pop(user_id, None)
            logger.debug(f"Cleaned up finished stream for user {user_id}")
    
    def get_connection_stats(self) -> Dict[str, Any]:
        """Get connection statistics."""
        return {
            "is_connected": self.is_connected,
            "reconnect_attempts": self._reconnect_attempts,
            "max_reconnect_attempts": self._max_reconnect_attempts,
            "should_reconnect": self._should_reconnect,
            "active_streams": len(self.active_streams),
            "pending_function_calls": len(self.pending_function_calls),
            "last_pong_time": self._last_pong_time.isoformat(),
            "websocket_closed": not self.websocket or self.websocket.closed,
        }


class RealtimeClientManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–¥–µ–ª—å–Ω—ã—Ö OpenAI –∫–ª–∏–µ–Ω—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    
    def __init__(self, yclients_adapter: YClientsAdapter):
        self.yclients_adapter = yclients_adapter
        self.user_clients: Dict[int, OpenAIRealtimeClient] = {}
        self._cleanup_task: Optional[asyncio.Task] = None
        self._start_cleanup_task()
        
        logger.info("üîß Initialized RealtimeClientManager for per-user sessions")
    
    def _start_cleanup_task(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Ñ–æ–Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –æ—á–∏—Å—Ç–∫–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤."""
        if self._cleanup_task is None or self._cleanup_task.done():
            self._cleanup_task = asyncio.create_task(self._cleanup_inactive_clients())
    
    async def _cleanup_inactive_clients(self):
        """–û—á–∏—â–∞–µ—Ç –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ —Å—Ç–∞—Ä—à–µ 1 —á–∞—Å–∞."""
        while True:
            try:
                current_time = datetime.utcnow()
                inactive_users = []
                
                for user_id, client in self.user_clients.items():
                    # –£–¥–∞–ª—è–µ–º –∫–ª–∏–µ–Ω—Ç–æ–≤ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –±–æ–ª–µ–µ 1 —á–∞—Å–∞
                    if (current_time - client._created_at).total_seconds() > 3600:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç—Ä–∏–º—ã
                        if not client.active_streams:
                            inactive_users.append(user_id)
                            logger.info(f"üßπ Marking user {user_id} client for cleanup (inactive for 1+ hour)")
                
                # –û—á–∏—â–∞–µ–º –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
                for user_id in inactive_users:
                    try:
                        client = self.user_clients.pop(user_id, None)
                        if client:
                            await client.disconnect()
                            logger.info(f"üóëÔ∏è Cleaned up inactive client for user {user_id}")
                    except Exception as e:
                        logger.error(f"Error cleaning up client for user {user_id}: {e}")
                
                # –°–ø–∏–º 30 –º–∏–Ω—É—Ç –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
                await asyncio.sleep(1800)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in cleanup task: {e}")
                await asyncio.sleep(300)  # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∂–¥–µ–º 5 –º–∏–Ω—É—Ç
    
    async def get_client_for_user(self, user_id: int) -> OpenAIRealtimeClient:
        """–ü–æ–ª—É—á–∞–µ—Ç –∏–ª–∏ —Å–æ–∑–¥–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        if user_id not in self.user_clients:
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            client = OpenAIRealtimeClient(self.yclients_adapter, user_id)
            await client.connect()
            self.user_clients[user_id] = client
            logger.info(f"‚úÖ Created and connected new client for user {user_id}")
        else:
            client = self.user_clients[user_id]
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
            if not client.is_connected:
                logger.info(f"üîÑ Reconnecting client for user {user_id}")
                await client.connect()
        
        return self.user_clients[user_id]
    
    async def remove_client_for_user(self, user_id: int) -> None:
        """–£–¥–∞–ª—è–µ—Ç –∫–ª–∏–µ–Ω—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
        if user_id in self.user_clients:
            client = self.user_clients.pop(user_id)
            await client.disconnect()
            logger.info(f"üóëÔ∏è Removed client for user {user_id}")
    
    async def cleanup_all(self) -> None:
        """–û—á–∏—â–∞–µ—Ç –≤—Å–µ—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤."""
        if self._cleanup_task and not self._cleanup_task.done():
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
        
        for user_id, client in self.user_clients.items():
            try:
                await client.disconnect()
                logger.info(f"üóëÔ∏è Disconnected client for user {user_id}")
            except Exception as e:
                logger.error(f"Error disconnecting client for user {user_id}: {e}")
        
        self.user_clients.clear()
        logger.info("üßπ All clients cleaned up")
    
    def get_stats(self) -> Dict[str, Any]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –º–µ–Ω–µ–¥–∂–µ—Ä–∞."""
        connected_clients = sum(1 for client in self.user_clients.values() if client.is_connected)
        active_streams = sum(len(client.active_streams) for client in self.user_clients.values())
        
        return {
            "total_clients": len(self.user_clients),
            "connected_clients": connected_clients,
            "active_streams": active_streams,
            "users": list(self.user_clients.keys())
        }


# Global client manager instance
_client_manager: Optional[RealtimeClientManager] = None


async def get_realtime_client(yclients_adapter: YClientsAdapter, user_id: int = 0) -> OpenAIRealtimeClient:
    """Get or create Realtime client for specific user."""
    global _client_manager
    
    if _client_manager is None:
        _client_manager = RealtimeClientManager(yclients_adapter)
    
    return await _client_manager.get_client_for_user(user_id)


async def cleanup_realtime_client() -> None:
    """Cleanup all Realtime clients."""
    global _client_manager
    
    if _client_manager:
        logger.info("Cleaning up all Realtime clients...")
        await _client_manager.cleanup_all()
        _client_manager = None


async def restart_realtime_client(yclients_adapter: YClientsAdapter, user_id: int = 0) -> OpenAIRealtimeClient:
    """Restart Realtime client with fresh settings."""
    logger.info(f"üîÑ Restarting Realtime client for user {user_id} with new settings...")
    
    global _client_manager
    if _client_manager:
        await _client_manager.remove_client_for_user(user_id)
    
    # Create new client with current settings
    return await get_realtime_client(yclients_adapter, user_id)
